# Nome do workflow que aparecerá na aba "Actions" do GitHub
name: Build and deploy Python app to Azure Web App - Rachaiapp

# Define os gatilhos que iniciarão o workflow
on:
  # Executa quando houver um push para a branch 'main'
  push:
    branches:
      - main
  # Permite que o workflow seja executado manualmente a partir da interface do GitHub
  workflow_dispatch:

# Define os jobs que serão executados
jobs:
  # Primeiro job: 'build'. Responsável por construir e preparar o artefato da aplicação.
  build:
    # O job será executado em uma máquina virtual Ubuntu mais recente
    runs-on: ubuntu-latest
    permissions:
      contents: read

    # Passos que compõem o job de build
    steps:
      # 1. Clona o código do seu repositório para a máquina virtual
      - name: Checkout code
        uses: actions/checkout@v4

      # 2. Configura o ambiente Python na versão especificada
      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      # 3. Cria o ambiente virtual, instala as dependências e executa o collectstatic
      #    Todos os comandos rodam no mesmo passo para garantir o contexto do 'venv'
      - name: Install dependencies and prepare app
        run: |
          python -m venv venv
          source venv/bin/activate
          pip install --upgrade pip
          pip install -r requirements.txt
          # Coleta os arquivos estáticos do Django para a pasta 'staticfiles'
          python manage.py collectstatic --noinput

      # 4. Limpa arquivos desnecessários para o deploy
      - name: Clean up files for deployment
        run: |
          # Remove o banco de dados local e o arquivo de variáveis de ambiente se existirem
          if [ -f db.sqlite3 ]; then rm db.sqlite3; fi
          if [ -f .env ]; then rm .env; fi

      # 5. Faz o upload do código preparado como um artefato
      #    Isto permite que o job de 'deploy' baixe e use esses arquivos
      - name: Upload artifact for deployment
        uses: actions/upload-artifact@v4
        with:
          name: python-app
          # Define o que será incluído no artefato: tudo, exceto o que for especificado
          path: |
            .
            !venv/
            !*.pyc
            !__pycache__/
            !.git/
            !.github/

  # Segundo job: 'deploy'. Responsável por enviar o código para o Azure.
  deploy:
    # O job será executado em uma máquina virtual Ubuntu
    runs-on: ubuntu-latest
    # Garante que o job 'build' termine com sucesso antes de iniciar o 'deploy'
    needs: build
    # Define o ambiente de deploy (útil para secrets e regras de proteção)
    environment:
      name: 'Production'
    # Define as permissões necessárias para o job
    permissions:
      id-token: write # Essencial para o login no Azure via OIDC (sem senhas)
      contents: read

    # Passos que compõem o job de deploy
    steps:
      # 1. Baixa o artefato 'python-app' que foi gerado no job de 'build'
      - name: Download artifact from build job
        uses: actions/download-artifact@v4
        with:
          name: python-app
          path: . # Extrai os arquivos para o diretório raiz

      - name: Login to Azure
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      # 3. Faz o deploy da aplicação para o Azure Web App
      - name: Deploy to Azure Web App
        uses: azure/webapps-deploy@v3
        id: deploy-to-webapp
        with:
          # Nome do seu Web App no Azure
          app-name: 'Rachaiapp'
          # Slot de deploy (geralmente 'Production')
          slot-name: 'Production'
          # A action empacotará automaticamente o conteúdo do diretório atual e enviará
          package: .
